---
title: "[OOP] 객체 지향의 4가지 특징 - 추상화, 상속, 다형성, 캡슐화"
author: master
date: 2024-09-01 15:37:00 +0900
categories: [cs]
tags: [공부, cs, oop, 추상화, 상속, 다형성, 캡슐화, 개념]
render_with_liquid: false
---

## 개요
---
객체 지향 프로그래밍(OOP: Object-Oriented Programing)은 컴퓨터 프로그램을 메시지를 주고받고 데이터를 처리할 수 있는 여러 개의 독립된 단위, 즉 "객체"들의 집합으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임이다.

객체 지향 프로그래밍을 적용하면 확장 및 보수가 용이한 대규모 소프트웨어를 개발하기에 유리하며, 또한 인간의 사고 방식과 유사하기 때문에 보다 직관적인 코드 분석이 가능하게 된다.

이러한 객체 지향 프로그래밍의 장점은 **추상화**, **상속**, **다형성**, **캡슐화**의 4가지 특성에 의해 극대화 된다.
각각의 특성이 무엇인지 알아보도록 하자.

## 추상화 Abstration
---
자료의 추상화란 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단히 만드는 것이다.
다시 말하면 객체의 공통적인 속성과 기능만을 추출해 자료형을 정의하는 것이 가능한데, 이것을 일반적으로 추상 클래스(Abstract class)라 부르며, 기능만을 추출해 정의한 것은 인터페이스(Interface)라 부른다.

추상 클래스와 인터페이스는 해당 클래스나 인터페이스를 구현하는 구현체에서 추상 메서드들을 구현하도록 강제하는 기능을 한다.
따라서 추상 클래스를 이용하면 추상 클래스의 기능을 하위 클래스에서 사용하거나 확장할 수 있고, 인터페이스를 이용하면 구현 객체들의 같은 동작을 보장할 수 있다.

정리하면, 객체 지향 프로그래밍에서는 보다 유연하고 변경이 용이한 프로그램을 설계하기 위해 역할과 구현을 분리하는데, 클래스나 인터페이스를 통해 역할을 추상화할 수 있는 것이다.

## 상속 Inheritance
---
상속은 새로운 클래스가 기존 클래스(부모 클래스)의 속성와 메서드를 이용할 수 있게 하는 것이다.

즉, 상속은 자식 클래스의 속성과 기능들을 부모 클래스로 추상화 시켜서 해당 상위 클래스를 상속받은 모든 하위 클래스들이 상위 클래스의 속성과 기능들을 간편하게 사용할 수 있도록 한다.

클래스들 간 공유되는 속성 및 기능을 상위 클래스에 한 번만 정의해 두면 간편하게 재사용하거나 선택적으로 재정의해 사용할 수 있어 반복적인 코드를 최소화할 수 있다.
또한 상속을 통해서 클래스 간의 종속 관계를 형성함으로써 객체를 조직화할 수 있다.

## 다형성 Polymorphism
---
다형성은 어떤 객체의 속성이나 기능이 상황, 맥락에 따라 여러 가지 형태를 가질 수 있는 특성이다.
대표적인 예시로 메서드 오버라이딩(Overriding, 같은 이름의 메서드가 여러 클래스에서 다른 기능을 하는 것)이나 메서드 오버로딩(Overloading, 같은 이름의 메서드가 인자의 개수나 자료형에 따라서 다른 기능을 하는 것)이 있다. 이는 같은 이름의 메서드가 상황에 따라 다른 기능을 수행하는 것이다.

또 다른 다형성의 중요한 예시는, 상위 클래스 타입의 참조 변수로 하위 클래스의 객체를 참조하는 것이다.
`Shape`이라는 상위 클래스를 상속받은 `Circle`, `Rectangle`, `Triangle` 클래스가 있다고 가정하자.
이 때 OOP의 다형성 개념을 이용하여 다음과 같은 정의가 가능하다.
```java
Shape shape1 = new Circle();
Shape shape2 = new Rectangle();
Shape shape3 = new Triangle();
```
즉, 상위 클래스인 `Shape`의 참조 변수로 하위 클래스를 참조받은 것이다. 이러한 다형성을 활용하면 다음과 같은 이점들이 있다.
1. 여러 (하위)클래스의 객체를 하나의 배열로 다룰 수 있다.
```java
Shape shapes[] = new Shape[3];
shapes[0] = shape1;
shapes[1] = shape2;
shapes[2] = shape3;
```
shape1, 2, 3은 서로 다른 클래스의 객체이지만 다형성을 이용해 하나의 배열로 만들어 다룰 수 있게 되어 더욱 간편하게 코드를 작성할 수 있다.
2. 객체 간 결합도를 낮출 수 있다.<br>
다형성을 적용하지 않았을 때, 아래와 같이 `Shape`와 관련된 계산들을 수행하는 클래스 `Calculator`를 만들 수 있다.
```java
class Calculator {
    // ...
    double getArea(Circle c) {
        return c.r * c.r * 3.14;
    }
    double getArea(Rectangle r) {
        return r.w * r.h;
    }
    double getArea(Triangle t) {
        return t.w * t.h / 2;
    }
    // ...
}
```
이렇게 작성한 경우, `Shape`의 하위 클래스로 `Star`라는 도형을 추가해야 할 때 문제가 생긴다. 내가 하고 싶은 것은 `Star` 클래스를 추가하는 것인데, 전혀 상관 없는 `Calculator` 클래스에 `Star`의 넓이를 구하는 메서드를 또 추가해야 한다. 이것은 객체 간의 의존성이 높기 때문에 발생하는 문제이다. `Calculator` 클래스가 `Circle`, `Rectangle`, `Triangle` 등 '직접 알고 있어야 하는' 다른 객체들이 너무 많다. 이것이 객체 간 의존성이 높은 상황이다.<br>
또한 삼각형의 넓이를 구하는 공식을 바꾼다고 가정해보자. 내가 수정하고 싶은 것은 `Triangle`에 관련된 내용인데, 마찬가지로 전혀 관계 없어 보이는 `Calculator` 클래스의 코드를 수정해야만 한다. 즉, 객체 간 의존성이 높은 경우 코드의 수정이 용이하지 않다.<br>
이러한 문제는 다음과 같이 해결할 수 있다.

```java
abstract class Shape {
    // ...
    abstract double getArea();
    // ...
}

class Calculator {
    // ...
    double getArea(Shape s) {
        return s.getArea();
    }
    // ...
}

class Circle extends Shape {
    // ...
    @Override
    double getArea() {
        return r * r * 3.14;
    }
    // ...
}

class Rectangle extends Shape {
    // ...
    @Override
    double getArea() {
        return w * h;
    }
    // ...
}
// ....
```

이런 식으로 코드를 작성하면, 새로운 클래스 `Star`가 추가될 때, 우리는 `Star` 클래스만 새롭게 추가하여 메서드들을 잘 오버라이드해서 정의해주기만 하면 된다. 다른 클래스들은 전혀 수정하지 않아도, `Calculator` 클래스의 `getArea()` 메서드는 항상 올바르게 동작할 것이다. 마찬가지로 `Triangle`의 넓이 구하는 공식을 수정하고 싶다면 `Triangle` 클래스만 수정해주면 된다.
다형성을 이용해서 부모 클래스인 `Shape`를 인자로 받기 때문에 모든 하위 클래스에 대해서 동작하는 메서드가 되었기 때문이다. 이 경우 `Calculator`는 `Circle`, `Rectangle`, `Triangle` 등을 직접 알지 못해도 된다.

이렇듯 다형성을 이용해 객체 간 의존도가 낮아지면 코드의 수정, 추가 등이 훨씬 간편해진다.


## 캡슐화 Encapsulation
---
캡슐화란 객체의 속성과 기능을 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉한다는 의미이다.
이것이 객체 지향에서 왜 필요할까? 아래 코드를 보자.
```java
class Main {
    public static void main(String[] args) {
        Circle c1 = new Circle(1);
        Circle c2 = new Circle(2);
        System.out.println(c1.getArea());
        System.out.println(c2.getArea());
    }
}
```
위 코드는 원 두 개를 만들어 반지름을 각각 1과 2로 설정하고, 각 원의 넓이를 출력하는 Main 메서드이다.

Main 메서드의 관점에서 한번 보자. Main 메서드는 원의 넓이를 실제로 어떻게 구하는지 몰라도 된다. 알 필요도 없다. 단지 `Circle` 클래스라는 캡슐 내에 잘 정의되어 있는 `getArea()`라는 메서드를 이용할 뿐이다.
캡슐화가 잘 지켜지지 않아 Main 메서드 내에서 원의 넓이를 구하는 로직을 작성해야 한다면, 원 객체가 많아질수록 코드의 중복도가 높아지고 실수가 발생할 확률도 높아질 것이다.

캡슐화 역시 추상화와 마찬가지로 객체 간 의존도를 낮춰주며, 다른 객체의 내부적인 동작 방식을 몰라도 되게 하기 때문에 코드의 확장성을 매우 높여준다. 우리가 다른 개발자가 만든 라이브러리를 가져다가 쉽게 사용할 수 있는 것도 이러한 캡슐화 덕분이라고 할 수 있다.

## 참고 자료
---
[객체 지향 프로그래밍](https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)

[추상 클래스 vs 인터페이스](https://brunch.co.kr/@kd4/6)

[캡슐화](https://bperhaps.tistory.com/entry/%EC%BA%A1%EC%8A%90%ED%99%94%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-%EC%96%B4%EB%96%A4-%EC%9D%B4%EC%A0%90%EC%9D%B4-%EC%9E%88%EB%8A%94%EA%B0%80)

[전체적인 설명](https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95)

